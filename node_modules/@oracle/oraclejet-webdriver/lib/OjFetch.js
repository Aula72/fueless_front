"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OjFetch = void 0;
class OjFetch {
    async fetch(driver, requestInfo, responseInfo, init) {
        // webdriver's async call marshalls objects on callback, so we have to unmarshall back into promise
        // We need to retrieve the body and headers during remote call, to use for recreation.
        let errResults;
        let retResults;
        const rInfo = JSON.stringify(requestInfo, null, 2);
        const remoteScript = `var input=arguments[0], info=arguments[1], init=arguments[2],  callback = arguments[arguments.length - 1], resp = {};
      fetch(input,init)
         .then(function(response) { 
          resp.ok = response.ok;
          resp.redirected = response.redirected;
          resp.status = response.status;
          resp.statusText = response.statusText;
          resp.type = response.type;
          resp.url = response.url;

           resp.marshalableHeaders = {};          
           response.headers.forEach(function(val, key) {
              resp.marshalableHeaders[key] = val; 
           });         
           if(info.responseBodyAs == "json") {
             response.json().
             then(function(json) {  resp.mbody = { "kind":"json", "body": json}; callback(resp);})
             .catch(function(error) { resp.error = "Fetch error on json(): " + error; callback(resp); });
           } else {
             response.text().then(function(text) { resp.mbody = { "kind":"text", "body": text}; callback(resp);})
             .catch(function(error) { resp.error = "Fetch error on text(): " + error; callback(resp);});
           }                                      
         })
         .catch(function(error) {         
          resp.error = "Fetch threw an exception: " + error;
          callback(resp);
          })`;
        try {
            // the browser fetch api RequestInit varies from the MarshalableRequestInit so we must convert.
            let fetchInit;
            if (init) {
                fetchInit = init;
                if (init.body) {
                    fetchInit.body = init.body.body;
                }
            }
            let resp = (await driver.executeAsyncScript(remoteScript, requestInfo, responseInfo, fetchInit));
            // console.log("resp = " + JSON.stringify(resp,null,2));
            let myResponse = {
                body: resp.mbody,
                headers: resp.marshalableHeaders,
                ok: resp.ok,
                redirected: resp.redirected,
                status: resp.status,
                statusText: resp.statusText,
                type: resp.type,
                url: resp.url
            };
            // console.log("myResponse = " + JSON.stringify(myResponse,null,2));
            if (resp.error) {
                return new Promise((resolve, reject) => {
                    reject('Response encountered error: ' +
                        resp.error +
                        '(requestInfo = ' +
                        rInfo +
                        ', response = ' +
                        JSON.stringify(resp, null, 2) +
                        ' status = ' +
                        resp.status +
                        ')');
                });
            }
            retResults = new Promise((resolve, reject) => {
                resolve(myResponse);
            });
        }
        catch (err) {
            retResults = new Promise((resolve, reject) => {
                reject('Unable to read Response: ' + err + '(requestInfo = ' + rInfo + ')');
            });
        }
        return retResults;
    }
}
exports.OjFetch = OjFetch;
//# sourceMappingURL=OjFetch.js.map
import { error, Locator, WebDriver, WebElement, WebElementPromise } from 'selenium-webdriver';

// Import OjWebElement directly from its file rather than through
// 'elements' package, to avoid circular dependency (elements will
// call to register themselves upon loading)
import { OjWebElement, ElementLocators } from '../elements/OjWebElement';
import { requeryElement } from './stale-element';
import { getBusyStates } from './busy-context-utils';

/**
 * Register a constructor for a custom WebElement for a given tag name.
 * @param tagName The DOM tag name for the custom element
 * @param ctor The constructor function for the custom WebElement
 */
export function register(
  tagName: string,
  ctor: new (el: WebElement, locators: ElementLocators) => OjWebElement
) {
  WebElementRegistry.register(tagName, ctor);
}

/**
 * Holds the value of the last page-type check. Updated each time when
 * WebDriver.findElement / findElements is called because any subsequent action
 * could've triggered a page change.
 * WebElement.findElement / findElements uses this var to avoid checking the
 * page type again because those methods can only be run on an element on the
 * existing page.
 * @private
 */
let lastIsJetPage = false;

/**
 * A registry which associates the constructors for custom WebElements with their
 * associated tag names. This registry should only be used internally by custom
 * WebElement implementations, and shouldn't be used directly in tests.
 * @private
 */
class WebElementRegistry {
  /**
   * Register a constructor for a custom WebElement for a given tag name.
   * @param tagName The DOM tag name for the custom element
   * @param ctor The constructor function for the custom WebElement
   */
  public static register(
    tagName: string,
    ctor: new (el: WebElement, locators: ElementLocators) => OjWebElement
  ) {
    WebElementRegistry.tagToCtorMap[tagName.toLowerCase()] = ctor;
  }
  /**
   * Get the constructor for a custom WebElement given a tag name.
   * @param tagName The DOM tag name for the custom element
   * @return A custom WebElement constructor for the given tagName, or undefined
   * if none exists.
   */
  public static get(
    tagName: string
  ): new (el: WebElement, locators: ElementLocators) => OjWebElement {
    return WebElementRegistry.tagToCtorMap[tagName.toLowerCase()];
  }
  /**
   * A mapping of element tag names to WebElement constructors
   */
  private static tagToCtorMap: {
    [tagName: string]: new (el: WebElement, locators: ElementLocators) => OjWebElement;
  } = {};
}

WebDriver.prototype.findElement = wrapFindElement(WebDriver.prototype.findElement);
WebDriver.prototype.findElements = wrapFindElements(WebDriver.prototype.findElements);

WebElement.prototype.findElement = wrapFindElement(WebElement.prototype.findElement);
WebElement.prototype.findElements = wrapFindElements(WebElement.prototype.findElements);

WebDriver.prototype.executeScript = wrapExecuteScript(WebDriver.prototype.executeScript);
WebDriver.prototype.executeAsyncScript = wrapExecuteScript(WebDriver.prototype.executeAsyncScript);

/**
 * Create a wrapper for findElement()
 * @param origFunc The original findElement function
 * @private
 */
function wrapFindElement(origFunc: (locator: Locator) => WebElementPromise) {
  return function findElement(locator: Locator): WebElementPromise {
    const isDriver = this instanceof WebDriver;
    const driver: WebDriver = isDriver ? this : this.getDriver();
    return new WebElementPromise(
      driver,
      new Promise<WebElement>(async (resolve, reject) => {
        try {
          // Only inspect page when called by driver object (not from WebElement)
          const isJet = (isDriver && (await isJetPage(this))) || lastIsJetPage;
          const el = await origFunc.call(this, locator);
          const parentEl = !isDriver && this;
          try {
            resolve(isJet ? await createTestAdapter(el, locator, parentEl) : el);
          } catch (ex) {
            // If exception appears while creating test adapter (an element probably disappeared)
            // we throw away found element and start over
            resolve(findElement.call(this, locator));
          }
        } catch (ex) {
          reject(ex);
        }
      })
    );
  };
}
/**
 * Create a wrapper for findElements()
 * @param origFunc The original findElements function
 * @private
 */
function wrapFindElements(origFunc: (locator: Locator) => Promise<WebElement[]>) {
  return async function findElements(locator: Locator): Promise<WebElement[]> {
    const isDriver = this instanceof WebDriver;
    // Only inspect page when called by driver object (not from WebElement)
    const isJet = (isDriver && (await isJetPage(this))) || lastIsJetPage;
    // Pass ourselves as parent if this is WebElement.findElements
    const elRef = !isDriver && this;
    const matches = await origFunc.call(this, locator);
    let weMatches: WebElement[] = [];
    if (isJet) {
      for (let el, i = 0, len = matches.length; i < len; i++) {
        el = matches[i];
        try {
          const ce = await createTestAdapter(el, locator, elRef, i);
          weMatches.push(ce);
        } catch (ex) {
          // If exception appears while creating test adapter (an element probably disappeared)
          // we throw away found elements and start over
          return findElements.call(this, locator);
        }
      }
    } else {
      weMatches = matches;
    }
    return weMatches;
  };
}

/**
 * Wrap WebDriver.executeScript/executeAsyncScript with a function that traps
 * StaleElementReferenceError and requeries the element(s) to try again
 * @param origFunc The original driver.executeScript/executeAsyncScript
 * @private
 */
function wrapExecuteScript(origFunc: <T>(...args: any) => Promise<T>) {
  return async function <T>(...args: any[]): Promise<T> {
    try {
      const ret: T = await origFunc.apply(this, args);
      return ret;
    } catch (ex) {
      if (ex instanceof error.StaleElementReferenceError) {
        const newArgs = [];
        const locators = [];
        for (let i = 0, len = args.length; i < len; i++) {
          let arg = args[i];
          // Requery arguments which are OjWebElements
          if (arg instanceof OjWebElement) {
            arg = await requeryElement(arg);
            locators.push(arg._locators?.elLocator);
          }
          newArgs.push(arg);
        }
        console.warn(`Trapped stale element executing script on ${locators}`);
        return origFunc.apply(this, newArgs);
      }
      throw ex;
    }
  };
}

/**
 * Test if the page is a JET page. This should be called each time
 * WebDriver findElement / findElements is called because any previous action
 * could've triggered a page change. It's not necessary to call for
 * WebElement findElement / findElements because that method can only be called
 * on an existing element reference within the same page. For elements, use
 * lastIsJetPage variable instead.
 *
 * @param driver WebDriver instance
 * @returns {boolean} Returns true if JET page, false otherwise
 * @private
 */
async function isJetPage(driver: WebDriver): Promise<boolean> {
  try {
    // Check that the page has RequireJS and ojs/ojcontext module
    // If it exists (JET page), then wait on the Busy Context.
    // If it doesn't exist, an error will be thrown, and this method will return
    // false.
    // It's also possible page is JET, but BusyContext timed out before script
    // completed. Catch BC timeout and also return true.
    lastIsJetPage = await driver.executeAsyncScript<boolean>(`
    const done = arguments[0];
    if (typeof require === 'function') {
      require(["ojs/ojcontext"], function(Context) {
        if (Context) {
          Context.getPageContext().getBusyContext()
          .whenReady().then(done)
          .catch(ex => done(true))
        } else {
          done(false);
        }
      }, function(err) { done(false) })
    } else {
      done(false);
    }
    `);
  } catch (ex) {
    // If timeout exception, then script timed out waiting on BusyContext
    if (ex instanceof error.TimeoutError || ex instanceof error.ScriptTimeoutError) {
      lastIsJetPage = true;
      const openStates = await getBusyStates(driver);
      throw Error(`BusyContext.whenReady() timed out. Busy states: ${openStates}`);
    }
    lastIsJetPage = false;
  }
  return lastIsJetPage;
}

/**
 * Create a custom WebElement from the original one. The WebElement constructor
 * is looked up in WebElementRegistry using the element's tag name, and the
 * registry is populated by each custom element. If no constructor is found,
 * OjWebElement is used.
 * @param el The original WebElement
 * @param elLocator The By locator used to originally locate the element
 * @param parentEl The immediate parent from which we were queried (WebElement.findElement)
 * @param elementsIndex The index within the array of WebElements returned from
 * findElements.
 * @return {OjWebElement} The test adapter for the given element, or OjWebElement
 * if none exists
 * @private
 */
async function createTestAdapter(
  el: WebElement,
  elLocator?: Locator,
  parentEl?: OjWebElement,
  elementsIndex?: number
): Promise<WebElement> {
  // This call can throw an exception which is caught in calling function
  const tagName = await el.getTagName();
  const ctor = WebElementRegistry.get(tagName) || OjWebElement;
  return new ctor(el, {
    elLocator,
    elementsIndex,
    parentEl,
    tagName
  });
}

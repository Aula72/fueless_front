/*
 * Your application specific code will go here
 */
import * as ko from "knockout";
import CoreRouter = require("ojs/ojcorerouter");
import ModuleRouterAdapter = require("ojs/ojmodulerouter-adapter");
import KnockoutRouterAdapter = require("ojs/ojknockoutrouteradapter");
import UrlParamAdapter = require("ojs/ojurlparamadapter");
import * as ThemeUtils from "ojs/ojthemeutils";
import * as ModuleElementUtils from "ojs/ojmodule-element-utils";
import * as ModuleAnimations from "ojs/ojmoduleanimations";
import ArrayDataProvider = require("ojs/ojarraydataprovider");
import * as KnockoutTemplateUtils from "ojs/ojknockouttemplateutils";
import "ojs/ojknockout";
import "ojs/ojmodule-element";
import { ModuleElementAnimation } from "ojs/ojmodule-element";
import { ojNavigationList } from "ojs/ojnavigationlist";
import { ModuleViewModel } from "ojs/ojmodule-element";
import Context = require("ojs/ojcontext");

interface CoreRouterDetail {
  label: string;
  iconClass: string;
};

class HeaderModel implements ModuleViewModel {
  pageTitle: string;
  adjustContentPadding: Function;

  constructor( { pageTitle, adjustContentPadding } : {
    pageTitle: string;
    adjustContentPadding: Function;
  }) {
    this.pageTitle = pageTitle;
    this.adjustContentPadding = adjustContentPadding;
  }

  transitionCompleted(): null {
    // adjust content padding after header bindings have been applied
    this.adjustContentPadding();
    return null;
  }
}

class RootViewModel {
  KnockoutTemplateUtils: typeof KnockoutTemplateUtils;
  manner: ko.Observable<string>;
  message: ko.Observable<string|undefined>;
  router: CoreRouter<CoreRouterDetail>;
  moduleAdapter: ModuleRouterAdapter<CoreRouterDetail>;
  navDataProvider: ojNavigationList<string, CoreRouter.CoreRouterState<CoreRouterDetail>>["data"];
  platform: string;
  selection: KnockoutRouterAdapter<CoreRouterDetail>;

  constructor () {
      this.KnockoutTemplateUtils = KnockoutTemplateUtils;

      // handle announcements sent when pages change, for Accessibility.
      this.manner = ko.observable("polite");
      this.message = ko.observable();

      let globalBodyElement: HTMLElement = document.getElementById("globalBody") as HTMLElement;
      globalBodyElement.addEventListener("announce", this.announcementHandler, false);

      // save the theme so we can perform platform specific navigational animations
      this.platform = ThemeUtils.getThemeTargetPlatform() as string;

      const navData = [
        { path: "", redirect: "dashboard" },
        { path: "dashboard", detail: { label: "Dashboard", iconClass: "oj-ux-ico-bar-chart" } },
        { path: "incidents", detail: { label: "Incidents", iconClass: "oj-ux-ico-fire" } },
        { path: "customers", detail: { label: "Customers", iconClass: "oj-ux-ico-contact-group" } },
        { path: "profile", detail: { label: "Profile", iconClass: "oj-ux-ico-contact" } },
        { path: "about", detail: { label: "About", iconClass: "oj-ux-ico-information-s" } }
      ];
      // router setup
      const router = new CoreRouter(navData, {
        urlAdapter: new UrlParamAdapter()
      });
      router.sync();

      this.moduleAdapter = new ModuleRouterAdapter(router, {
        // If Android device, use "fade" animation
        animationCallback: this.platform === "android" ?
          (animationContext) => "fade"
          : undefined
      });

      this.selection = new KnockoutRouterAdapter(router);

      // Setup the navDataProvider with the routes, excluding the first redirected
      // route.
      this.navDataProvider = new ArrayDataProvider(navData.slice(1), {keyAttributes: "path"});

      // release the application bootstrap busy state
      Context.getPageContext().getBusyContext().applicationBootstrapComplete();        
    }

    announcementHandler = (event: any): void => {
      this.message(event.detail.message);
      this.manner(event.detail.manner);
    }

    // header Setup
    getHeaderModel(): HeaderModel {
      let pageTitle: string = this.selection.state().detail.label;
      let adjustContentPadding: Function = this.adjustContentPadding;
      return new HeaderModel( { pageTitle, adjustContentPadding } );
    }

    // method for adjusting the content area top/bottom paddings to avoid overlap with any fixed regions.
    // this method should be called whenever your fixed region height may change.  The application
    // can also adjust content paddings with css classes if the fixed region height is not changing between
    // views.
    adjustContentPadding(): void {
      let topElem: HTMLElement = document.getElementsByClassName("oj-applayout-fixed-top")[0] as HTMLElement;
      let contentElem: HTMLElement = document.getElementsByClassName("oj-applayout-content")[0] as HTMLElement;
      let bottomElem: HTMLElement = document.getElementsByClassName("oj-applayout-fixed-bottom")[0] as HTMLElement;

      if (topElem) {
        contentElem.style.paddingTop = `${topElem.offsetHeight}px`;
      }

      if (bottomElem) {
        contentElem.style.paddingBottom = `${bottomElem.offsetHeight}px`;
      }
      // add oj-complete marker class to signal that the content area can be unhidden.
      // see the override.css file to see when the content area is hidden.
      contentElem.classList.add("oj-complete");
    }
}

export default new RootViewModel();

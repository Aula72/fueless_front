/* @oracle/oraclejet-preact: 14.0.4 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
require('./UNSAFE_Floating.js');
var UNSAFE_Layer = require('./UNSAFE_Layer.js');
var hooks_UNSAFE_useOutsideClick = require('./hooks/UNSAFE_useOutsideClick.js');
var hooks_PRIVATE_useCollectionFocusRing = require('./hooks/PRIVATE_useCollectionFocusRing.js');
var utils_UNSAFE_mergeProps = require('./utils/UNSAFE_mergeProps.js');

var MenuItem = require('./MenuItem-2928619f.js');
var Floating = require('./Floating-cea8b705.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook for handling current key update due to user interaction including keyboard navigation.
 *
 * @param keyExtractor function to extract the key based on the provided element
 * @param getPrevKey function to get the previous key based on the current key
 * @param getNextKey function to get the next key based on the current key
 * @param getFirstVisibleKey function to get the key of the first available item
 * @param getLastVisibleKey function to get the key of the last available item
 * @param currentKey the current key
 * @param onChange function to invoke if the current key has changed
 * @returns
 */
function useMenuCurrentKey(keyExtractor, getPrevKey, getNextKey, getFirstVisibleKey, getLastVisibleKey, currentKey, onChange) {
    const onKeyDown = hooks.useCallback((event) => {
        if (onChange) {
            // TODO: support horizontal layout on icon menu (left/right arrow key)
            if (event.key === 'ArrowDown' && !event.shiftKey) {
                const nextKey = getNextKey();
                if (nextKey && currentKey != nextKey) {
                    onChange({ value: nextKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'ArrowUp' && !event.shiftKey) {
                const prevKey = getPrevKey();
                if (prevKey && currentKey != prevKey) {
                    onChange({ value: prevKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'Home') {
                const firstKey = getFirstVisibleKey();
                if (firstKey && currentKey != firstKey) {
                    onChange({ value: firstKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'End') {
                const lastKey = getLastVisibleKey();
                if (lastKey && currentKey != lastKey) {
                    onChange({ value: lastKey });
                }
                event.preventDefault();
            }
        }
    }, [currentKey, getNextKey, getPrevKey, onChange, getFirstVisibleKey, getLastVisibleKey]);
    //Capture needed since usePress stop propagation, what produces not triggering this event.
    //We can't stop propagation here, because if we do that, usePress onClick will not be triggered.
    const onClickCapture = hooks.useCallback((event) => {
        if (onChange && !event.shiftKey) {
            const nextKey = keyExtractor(event.target);
            if (nextKey && currentKey != nextKey) {
                onChange({ value: nextKey });
            }
        }
    }, [currentKey, keyExtractor, onChange]);
    const currentKeyProps = onChange == null ? {} : { onClickCapture, onKeyDown };
    return { currentKeyProps };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the key from the item element
 */
const getKey = (item) => {
    // Key is set on data-oj-menu-item-key on each menuItem. To get this key from the
    // the actual menuItem we need to do a kebab to camel-case conversion.
    return item.dataset['ojMenuItemKey'];
};
/**
 * A helper function that return the key of the first available item.
 */
const getFirstVisibleKey = (root) => {
    if (root) {
        const firstItem = root.querySelector('[data-oj-menu-item-key]');
        if (firstItem) {
            const key = getKey(firstItem);
            if (key) {
                return key;
            }
        }
    }
    return null;
};
/**
 * A helper function that return the key of the last available item.
 */
const getLastVisibleKey = (root) => {
    if (root) {
        const items = root.querySelectorAll('[data-oj-menu-item-key]');
        const lastItem = items[items.length - 1];
        if (lastItem) {
            const key = getKey(lastItem);
            if (key) {
                return key;
            }
        }
    }
    return null;
};
/**
 * A helper function that returns the key of the previous or the next item
 * given the specified current key
 */
const getPrevNextKey = (root, isPrev, currentKey) => {
    return () => {
        if (root) {
            const items = Array.from(root.querySelectorAll('[data-oj-menu-item-key]'));
            const currentKeyIndex = items.findIndex((item) => getKey(item) === currentKey);
            let nextIndex = currentKeyIndex + (isPrev ? -1 : 1);
            const itemsLastIndex = items.length - 1;
            if (nextIndex < 0) {
                nextIndex = itemsLastIndex;
            }
            if (nextIndex > itemsLastIndex) {
                nextIndex = 0;
            }
            return getKey(items[nextIndex]) || null;
        }
        return null;
    };
};
/**
 * A helper function to get the key from an element
 */
const keyExtractor = (element) => {
    const item = element.closest('[data-oj-menu-item-key]');
    if (item) {
        const key = getKey(item);
        return key === undefined ? null : key;
    }
    return null;
};
/**
 * Function to get the corresponding keyboard behavior to close the menu.
 */
const getKeyboardCloseProps = (onClose) => {
    const onKeyDown = (event) => {
        if (event.key === 'Tab') {
            onClose === null || onClose === void 0 ? void 0 : onClose({ reason: 'tabbing' });
            event.preventDefault(); //TODO: Revisit this since we should let focus be at its natural flow, quick solution for now to focus correct item in main use case
        }
        else if (event.key === 'Escape') {
            onClose === null || onClose === void 0 ? void 0 : onClose({ reason: 'cancel' });
        }
    };
    return { onKeyDown };
};
/**
 * Function to get the corresponding specific behavior for clicking/touching down menuContainer
 */
const getMenuPointerDown = () => {
    const onPointerDown = (event) => {
        //We just want to prevent default when element that was
        //pressed down was not a menu item. Using this flag removes issues
        //related to focus visibilty on "long press"
        const nextKey = keyExtractor(event.target);
        if (!nextKey) {
            event.preventDefault();
        }
    };
    return { onPointerDown };
};

const styles = {
  // TODO: Handle vertical and horizontal overflow. Get rid of maxWidth on a next drop so horizontal and also vertical flow is handled correctly.
  // It's hard to relay just in css, we might need to relay on some kind of observer. Maybe should be handled on Floating/Dropdown component.
  floatingContainer: "cgffya",
  menuContainer: "_15bff7d"
};
const Menu = ({
  children,
  isOpen = false,
  anchorRef,
  onClose,
  accessibleLabel,
  initialFocus = 'menu'
}) => {
  const floatingRef = hooks.useRef(null);
  const menuContainerRef = hooks.useRef(null);
  const isOpenPrevValue = hooks.useRef();
  const [currentKey, setCurrentKey] = hooks.useState();
  const [possibleFocus, setPossibleFocus] = hooks.useState('pending');
  const changeKey = hooks.useCallback(detail => {
    setCurrentKey(detail.value);
    setPossibleFocus('firstItem');
  }, []);
  const [showFocusRing, focusRingProps] = hooks_PRIVATE_useCollectionFocusRing.useCollectionFocusRing(elem => {
    var _a;

    return !!((_a = menuContainerRef.current) === null || _a === void 0 ? void 0 : _a.contains(elem));
  }, ['ArrowUp', 'ArrowDown'], elem => {
    const nextKey = keyExtractor(elem);
    return !!nextKey;
  });
  const {
    currentKeyProps
  } = useMenuCurrentKey(element => keyExtractor(element), getPrevNextKey(menuContainerRef.current, true, currentKey), getPrevNextKey(menuContainerRef.current, false, currentKey), () => getFirstVisibleKey(menuContainerRef.current), () => getLastVisibleKey(menuContainerRef.current), currentKey, changeKey);
  const useOutsideClickHandler = hooks.useCallback(e => {
    onClose === null || onClose === void 0 ? void 0 : onClose({
      reason: 'outsideClick',
      target: e.target
    });
  }, [onClose]);
  hooks_UNSAFE_useOutsideClick.useOutsideClick({
    isDisabled: !isOpen,
    ref: [floatingRef],
    handler: useOutsideClickHandler
  });
  hooks.useEffect(() => {
    if (isOpen === isOpenPrevValue.current) return;

    if (isOpen) {
      const menuContainer = menuContainerRef.current;

      if (menuContainer) {
        if (initialFocus === 'menu') {
          // At this point floating has visibility set as hidden, so also menuContainer. Settimeout added so menuContainer
          // is visible at that point and can be focused
          setTimeout(() => {
            menuContainer.focus();
          }, 0);
          setPossibleFocus('menu');
        } else {
          const firstItemKey = getFirstVisibleKey(menuContainerRef.current);

          if (firstItemKey) {
            changeKey({
              value: firstItemKey
            });
          } else {
            setPossibleFocus('menu');
          }
        }
      }
    } else {
      setPossibleFocus('pending');
      setCurrentKey(undefined);
    }

    isOpenPrevValue.current = isOpen;
  }, [isOpen, initialFocus, changeKey]); // TODO - Reuse a dropdown component instead of creating floating by ourselves.

  return !isOpen ? null : jsxRuntime.jsx(UNSAFE_Layer.Layer, Object.assign({
    logicalParentRef: anchorRef
  }, {
    children: jsxRuntime.jsx(Floating.Floating, Object.assign({
      class: styles.floatingContainer,
      ref: floatingRef,
      anchorRef: anchorRef,
      placement: "bottom-start",
      offsetValue: {
        mainAxis: 4,
        crossAxis: 0
      }
    }, {
      children: jsxRuntime.jsx(MenuItem.MenuContext.Provider, Object.assign({
        value: {
          onClose,
          currentKey,
          showFocusRing
        }
      }, {
        children: jsxRuntime.jsx("div", Object.assign({
          style: {
            minWidth: `${anchorRef.current && anchorRef.current.offsetWidth > MENU_MIN_WIDTH ? anchorRef.current.offsetWidth : MENU_MIN_WIDTH}px`
          },
          ref: menuContainerRef,
          tabIndex: possibleFocus === 'firstItem' ? -1 : 0,
          role: "menu",
          "aria-label": accessibleLabel,
          class: styles.menuContainer
        }, utils_UNSAFE_mergeProps.mergeProps(focusRingProps, currentKeyProps, getMenuPointerDown(), getKeyboardCloseProps(onClose)), {
          children: children
        }))
      }))
    }))
  }));
};
const MENU_MIN_WIDTH = 200;

exports.Menu = Menu;
/*  */
//# sourceMappingURL=Menu-7bc3a21d.js.map

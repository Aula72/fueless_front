/* @oracle/oraclejet-preact: 14.0.4 */
'use strict';

var tslib_es6 = require('./tslib.es6-e79a0c43.js');
var jsxRuntime = require('preact/jsx-runtime');

var hooks_UNSAFE_useFormFieldContext = require('./hooks/UNSAFE_useFormFieldContext.js');
var hooks_UNSAFE_useTabbableMode = require('./hooks/UNSAFE_useTabbableMode.js');
var hooks_UNSAFE_useTextFieldInputHandlers = require('./hooks/UNSAFE_useTextFieldInputHandlers.js');
require('./utils/UNSAFE_classNames.js');
var utils_UNSAFE_interpolations_text = require('./utils/UNSAFE_interpolations/text.js');
var utils_UNSAFE_mergeInterpolations = require('./utils/UNSAFE_mergeInterpolations.js');
var FormControlUtils = require('./FormControlUtils-d37ad806.js');
var classNames = require('./classNames-fe0c9b44.js');

const textFieldStyles = {
  base: "_1vquuhh",
  embedded: "_26y7bk",
  nonReadonly: "_1szcb0m"
};
const readonlyStyles = {
  base: "_9nhgvu",
  insideEnabledForm: "_1t52aju",
  textarea: "_13eo4lt",
  insideEnabledFormLabelInside: "blgq5i",
  notInsideEnabledForm: "_1t9ulfx",
  textareaNotInsideEnabledForm: "_6zrbi5"
}; //Consolidating all loading styles on form elements here

const loadingStyles = "_1emlwio";
const getTextFieldClasses = (readonly, variant) => {
  return classNames.classNames([textFieldStyles.base, variant === 'embedded' && textFieldStyles.embedded, !readonly && textFieldStyles.nonReadonly]);
};
const getReadonlyClasses = (isInsideNonReadonlyForm, hasInsideLabel, variant) => {
  const classes = classNames.classNames([readonlyStyles.base, variant === 'textarea' && readonlyStyles.textarea, isInsideNonReadonlyForm ? readonlyStyles.insideEnabledForm : readonlyStyles.notInsideEnabledForm, variant === 'textarea' && !isInsideNonReadonlyForm && readonlyStyles.textareaNotInsideEnabledForm, isInsideNonReadonlyForm && hasInsideLabel && readonlyStyles.insideEnabledFormLabelInside]);
  return classes;
};
const getInputId = id => {
  return (id !== null && id !== void 0 ? id : '') + '|input';
};
const isInputPlaceholderShown = (hasInsideLabel, hasValue, isFocused) => {
  return !(hasInsideLabel && !hasValue && !isFocused);
};

const rootStyles = {
  base: "_1xx6zc4",
  // removes margin that Safari adds to the input element
  input: "_10pkbs2",
  textarea: "_14znmb8",
  password: "_1dz7ja9",
  labelDefaultPadding: "h580em",
  labelInsideBase: "_17p2r1b",
  textareaLabelInsideBase: "_1qnb81q",
  labelInsideNoValueAndHasFocus: "_1fg0y9j",
  hasStartContent: "_121rm2v",
  hasEndContent: "_1x4c4tu",
  defaultColor: "_1k3uw3m",
  disabledColor: "_6blyma",
  // The 0.25em is the space between the prefix and the input. This is equivalent to ' '.
  hasPrefix: "o2aw8g",
  hasSuffix: "_1cvjx76",
  default: "_1tbfs7f",
  defaultPaddingStart: "qrcszf",
  defaultPaddingEnd: "_2jsphq",
  embedded: "_9thnu3"
};
const interpolations = [...Object.values(utils_UNSAFE_interpolations_text.textInterpolations)];
const styleInterpolations = utils_UNSAFE_mergeInterpolations.mergeInterpolations(interpolations);
const TextFieldInput = _a => {
  var {
    as = 'input',
    ariaAutoComplete,
    ariaControls,
    ariaDescribedBy,
    ariaExpanded,
    ariaInvalid,
    ariaLabel,
    ariaLabelledBy,
    ariaValueMax,
    ariaValueMin,
    ariaValueNow,
    ariaValueText,
    autoComplete,
    autoFocus,
    currentCommitValue,
    hasEndContent = false,
    hasInsideLabel = false,
    hasPrefix = false,
    hasStartContent = false,
    hasSuffix = false,
    id,
    inputRef,
    placeholder,
    isRequired,
    role,
    rows,
    spellcheck,
    type,
    value = '',
    variant = 'default',
    onInput,
    onCommit,
    onKeyDown,
    onKeyUp
  } = _a,
      props = tslib_es6.__rest(_a, ["as", "ariaAutoComplete", "ariaControls", "ariaDescribedBy", "ariaExpanded", "ariaInvalid", "ariaLabel", "ariaLabelledBy", "ariaValueMax", "ariaValueMin", "ariaValueNow", "ariaValueText", "autoComplete", "autoFocus", "currentCommitValue", "hasEndContent", "hasInsideLabel", "hasPrefix", "hasStartContent", "hasSuffix", "id", "inputRef", "placeholder", "isRequired", "role", "rows", "spellcheck", "type", "value", "variant", "onInput", "onCommit", "onKeyDown", "onKeyUp"]);

  const hasValue = value !== '';
  const {
    isDisabled,
    isFocused,
    isLoading,
    isReadonly
  } = hooks_UNSAFE_useFormFieldContext.useFormFieldContext();
  const myPlaceholder = isInputPlaceholderShown(hasInsideLabel, hasValue, isFocused) ? placeholder : undefined;
  const {
    class: styleInterpolationClasses
  } = styleInterpolations(props);
  const renderPrefix = !isDisabled && hasPrefix;
  const renderSuffix = !isDisabled && hasSuffix;
  const inputClasses = classNames.classNames(['oj-c-text-field-input', rootStyles.base, variant === 'default' ? classNames.classNames([rootStyles.default, as === 'textarea' && rootStyles.textarea, as === 'input' && rootStyles.input, type === 'password' && rootStyles.password, !hasStartContent && !renderPrefix && rootStyles.defaultPaddingStart, !hasEndContent && !renderSuffix && rootStyles.defaultPaddingEnd]) : rootStyles.embedded, hasInsideLabel && classNames.classNames([rootStyles.labelInsideBase, as === 'textarea' && rootStyles.textareaLabelInsideBase, !hasValue && isFocused && rootStyles.labelInsideNoValueAndHasFocus]), !hasInsideLabel && as !== 'textarea' && rootStyles.labelDefaultPadding, // We want the input to have padding on itself. This gives the user more space to click on to set focus to the input.
  // The padding between the input and the icon is different than the padding between the input and prefix/suffix (since they are both text)
  // startcontentpadding+input+endcontentpadding
  hasStartContent && !hasPrefix && rootStyles.hasStartContent, hasEndContent && !hasSuffix && rootStyles.hasEndContent, isDisabled ? rootStyles.disabledColor : rootStyles.defaultColor, // prefix+prefixpadding+input+suffixpadding+suffix
  // if there is also a startcontent or end content,
  // the prefix/suffix will have that padding on it (see PrefixSuffix)
  renderPrefix && rootStyles.hasPrefix, renderSuffix && rootStyles.hasSuffix, styleInterpolationClasses]);
  const Comp = as || 'input';
  const handlers = hooks_UNSAFE_useTextFieldInputHandlers.useTextFieldInputHandlers({
    currentCommitValue,
    value,
    onInput,
    onCommit,
    onKeyDown
  }); // the implicit default for tabindex on an input is 0, so do not explicitly set it.
  // JET-52914 - Implement Tabbable mode API contract in InputText
  // if not tabbable, spread tabbableModeProps on component

  const {
    isTabbable,
    tabbableModeProps
  } = hooks_UNSAFE_useTabbableMode.useTabbableMode(); // TODO: for autoComplete='off', need to configure attrs appropriately to make sure it
  // works across browsers and versions  (from review on 3/11/22)

  return jsxRuntime.jsx(Comp, Object.assign({
    "aria-autocomplete": ariaAutoComplete,
    "aria-controls": ariaControls,
    "aria-describedby": ariaDescribedBy,
    "aria-expanded": ariaExpanded,
    "aria-invalid": ariaInvalid,
    "aria-label": isLoading ? FormControlUtils.getLoadingAriaLabel() : ariaLabel ? ariaLabel : undefined,
    "aria-labelledby": ariaLabelledBy,
    "aria-required": isRequired ? true : undefined,
    "aria-valuemax": ariaValueMax,
    "aria-valuemin": ariaValueMin,
    "aria-valuenow": ariaValueNow,
    "aria-valuetext": ariaValueText,
    autocomplete: autoComplete,
    autofocus: autoFocus,
    class: inputClasses,
    disabled: isDisabled,
    id: id,
    onKeyUp: onKeyUp,
    placeholder: myPlaceholder,
    readonly: isReadonly,
    // @ts-ignore
    ref: inputRef,
    role: role,
    rows: rows,
    spellcheck: spellcheck,
    type: type,
    value: value
  }, handlers, !isTabbable && tabbableModeProps));
};

exports.TextFieldInput = TextFieldInput;
exports.getInputId = getInputId;
exports.getReadonlyClasses = getReadonlyClasses;
exports.getTextFieldClasses = getTextFieldClasses;
exports.loadingStyles = loadingStyles;
/*  */
//# sourceMappingURL=TextFieldInput-6db2cca1.js.map

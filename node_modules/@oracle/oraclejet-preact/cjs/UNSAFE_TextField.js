/* @oracle/oraclejet-preact: 14.0.4 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ReadonlyTextFieldInput = require('./ReadonlyTextFieldInput-b98e7e48.js');
var tslib_es6 = require('./tslib.es6-e79a0c43.js');
var jsxRuntime = require('preact/jsx-runtime');
var hooks_UNSAFE_useFormContext = require('./hooks/UNSAFE_useFormContext.js');
var UNSAFE_LabelValueLayout = require('./UNSAFE_LabelValueLayout.js');
require('./utils/UNSAFE_classNames.js');
var FormControlUtils = require('./FormControlUtils-d37ad806.js');
var TextFieldInput = require('./TextFieldInput-6db2cca1.js');
var hooks_UNSAFE_useFormFieldContext = require('./hooks/UNSAFE_useFormFieldContext.js');
var classNames = require('./classNames-fe0c9b44.js');
var preact = require('preact');
require("identity-obj-proxy");
require('./UNSAFE_Flex.js');
var Flex = require('./Flex-70f45c1b.js');
var hooks_UNSAFE_useDebounce = require('./hooks/UNSAFE_useDebounce.js');
var hooks_UNSAFE_useTranslationBundle = require('./hooks/UNSAFE_useTranslationBundle.js');
var UNSAFE_LiveRegion = require('./UNSAFE_LiveRegion.js');
require('./hooks/UNSAFE_useTabbableMode.js');
require('preact/hooks');
require('./utils/UNSAFE_interpolations/text.js');
require('./keys-fcc45418.js');
require('./_curry1-8dba47c0.js');
require('./_has-f646b7fa.js');
require('./utils/UNSAFE_mergeInterpolations.js');
require('./_curry3-a11ae74a.js');
require('./_curry2-35fe759b.js');
require('./utils/UNSAFE_size.js');
require('./hooks/UNSAFE_useTextFieldInputHandlers.js');
require('./utils/PRIVATE_clientHints.js');
require('./clientHints-6f362777.js');
require('./utils/UNSAFE_interpolations/dimensions.js');
require('./utils/UNSAFE_arrayUtils.js');
require('./utils/UNSAFE_interpolations/boxalignment.js');
require('./utils/UNSAFE_interpolations/flexbox.js');
require('./flexbox-e7360e12.js');
require('./utils/UNSAFE_interpolations/flexitem.js');
require('./flexitem-21bb492c.js');
require('./UNSAFE_Environment.js');
require('./UNSAFE_Layer.js');
require('preact/compat');

const StartTopLabelReadonlyTextField = (_a) => {
    var { outerClassNames, innerClassNames, label, labelEdge, labelStartWidth, inlineUserAssistance, children } = _a, props = tslib_es6.__rest(_a, ["outerClassNames", "innerClassNames", "label", "labelEdge", "labelStartWidth", "inlineUserAssistance", "children"]);
    return (jsxRuntime.jsxs("div", Object.assign({}, props, { class: outerClassNames }, { children: [jsxRuntime.jsx(UNSAFE_LabelValueLayout.LabelValueLayout, Object.assign({ label: label, labelEdge: labelEdge, labelStartWidth: labelStartWidth }, { children: jsxRuntime.jsx("div", Object.assign({ class: innerClassNames }, { children: children })) })), inlineUserAssistance] })));
};
const InsideLabelReadonlyTextField = (_a) => {
    var { outerClassNames, innerClassNames, inlineUserAssistance, children } = _a, props = tslib_es6.__rest(_a, ["outerClassNames", "innerClassNames", "inlineUserAssistance", "children"]);
    return (jsxRuntime.jsxs("div", Object.assign({}, props, { class: outerClassNames }, { children: [jsxRuntime.jsx("div", Object.assign({ class: innerClassNames }, { children: children })), inlineUserAssistance] })));
};
const ReadonlyTextField = (_a) => {
    var { label, labelEdge, children, variant } = _a, props = tslib_es6.__rest(_a, ["label", "labelEdge", "children", "variant"]);
    const { isFormLayout, isReadonly: isReadonlyForm } = hooks_UNSAFE_useFormContext.useFormContext();
    const { isLoading } = hooks_UNSAFE_useFormFieldContext.useFormFieldContext();
    const hasInsideLabel = label !== undefined && labelEdge === 'inside';
    // TODO: We need to re-evaluate how we use CSS multi-classing to our VDOM components
    const formControlClassNames = FormControlUtils.getFormControlClasses(hasInsideLabel);
    const textFieldClassNames = TextFieldInput.getTextFieldClasses(true);
    const readonlyClassNames = TextFieldInput.getReadonlyClasses(isFormLayout && !isReadonlyForm, hasInsideLabel, variant);
    const outerClassNames = classNames.classNames([formControlClassNames, textFieldClassNames]);
    const innerClassNames = classNames.classNames([readonlyClassNames, isLoading && TextFieldInput.loadingStyles]);
    if (label !== undefined && (labelEdge === 'start' || labelEdge === 'top')) {
        return (jsxRuntime.jsx(StartTopLabelReadonlyTextField, Object.assign({ outerClassNames: outerClassNames, innerClassNames: innerClassNames, label: label, labelEdge: labelEdge }, props, { children: children })));
    }
    return (jsxRuntime.jsxs(InsideLabelReadonlyTextField, Object.assign({ outerClassNames: outerClassNames, innerClassNames: innerClassNames }, props, { children: [label, children] })));
};

const ojButtonHeight = '2.75rem'; // TODO: replace this with var(--oj-button-sm-height) once it is available

const ojButtonSmHeight = '2.25rem'; // TODO: replace this with var(--oj-button-icon-size) once it is available

const ojButtonIconSize = 'var(--oj-c-PRIVATE-DO-NOT-USE-core-icon-size-lg)'; // TODO: replace this with var(--oj-button-sm-icon-size) once it is available

const ojButtonSmIconSize = '1.25rem';
const textFieldContainerStyles = {
  base: "_1wizcp4",
  defaultStyles: "_1pnmx5d",
  embeddedStyles: "xtaau2",
  showBorder: "_5h46jg",
  textarea: "_1b2xh28",
  labelInside: "_42nlmd",
  focused: "pzetk5",
  resize: {
    both: "_1e5vsly",
    horizontal: "wcsdcv",
    vertical: "_1ahpz6i"
  },
  disabled: "_1pgx76x",
  error: "_1utx3uw",
  warning: "_1xyxlpv"
};
const textFieldStartContentStyles = {
  base: "l5xmd2",
  labelInside: "_1excimo",
  disabled: "_7k1xwe"
};
const textFieldMiddleStyles = {
  base: "_1y5u5eu",
  textarea: "kxmtyl"
};
const textFieldEndContentStyles = {
  base: "_15cafzu",
  labelInside: "_5e4y6t"
}; // Renders the oj-text-field-container dom which includes the
// start, middle (where the inside label and inputElem goes),
// and end pieces of the form component.
// This does not include user assistance because that is rendered outside the
// oj-text-field-container; that is rendered in the TextField component.

const TextFieldContent = ({
  contentVariant = 'input',
  insideLabel,
  mainContent,
  startContent,
  statusVariant = 'none',
  styleVariant = 'default',
  endContent,
  resize,
  rootRef
}) => {
  const {
    isDisabled,
    isFocused,
    isLoading
  } = hooks_UNSAFE_useFormFieldContext.useFormFieldContext();
  const rootStyles = classNames.classNames([textFieldContainerStyles.base, styleVariant === 'embedded' ? classNames.classNames([textFieldContainerStyles.embeddedStyles, statusVariant !== 'none' && textFieldContainerStyles.showBorder]) : classNames.classNames([textFieldContainerStyles.defaultStyles, textFieldContainerStyles.showBorder, insideLabel !== undefined && textFieldContainerStyles.labelInside, isFocused && textFieldContainerStyles.focused, contentVariant === 'textarea' && textFieldContainerStyles.textarea]), resize && textFieldContainerStyles.resize[resize], isDisabled ? textFieldContainerStyles.disabled : classNames.classNames([statusVariant === 'error' && textFieldContainerStyles.error, statusVariant === 'warning' && textFieldContainerStyles.warning, // TODO: don't use class names: https://jira.oraclecorp.com/jira/browse/JET-50572
  statusVariant !== 'none' && `oj-c-text-field-${statusVariant}`]), isLoading && TextFieldInput.loadingStyles]);
  const startContentStyles = classNames.classNames([textFieldStartContentStyles.base, insideLabel != undefined && textFieldStartContentStyles.labelInside, isDisabled && textFieldStartContentStyles.disabled]);
  const middleStyles = classNames.classNames([textFieldMiddleStyles.base, contentVariant === 'textarea' && textFieldMiddleStyles.textarea // getMiddleContentVariantStyles(variant)
  ]);
  const endContentStyles = classNames.classNames([textFieldEndContentStyles.base, insideLabel != undefined && textFieldEndContentStyles.labelInside]);
  return jsxRuntime.jsxs("div", Object.assign({
    role: "presentation",
    class: rootStyles,
    ref: rootRef
  }, {
    children: [startContent && jsxRuntime.jsx("span", Object.assign({
      class: startContentStyles
    }, {
      children: jsxRuntime.jsx(Flex.Flex, Object.assign({
        justify: "center",
        align: "center",
        hasZeroMargins: true
      }, {
        children: startContent
      }))
    })), jsxRuntime.jsxs("div", Object.assign({
      class: middleStyles
    }, {
      children: [insideLabel, mainContent]
    })), endContent && jsxRuntime.jsx("span", Object.assign({
      class: endContentStyles
    }, {
      children: jsxRuntime.jsx(Flex.Flex, Object.assign({
        justify: "center",
        align: "center",
        hasZeroMargins: true
      }, {
        children: endContent
      }))
    }))]
  }));
};

const StyledTextField = (_a) => {
    var { hasInsideLabel = false, variant = 'default' } = _a, props = tslib_es6.__rest(_a, ["hasInsideLabel", "variant"]);
    const { isReadonly } = hooks_UNSAFE_useFormFieldContext.useFormFieldContext();
    // TODO: We need to re-evaluate how we use CSS multi-classing to our VDOM components
    const formControlClassNames = FormControlUtils.getFormControlClasses(hasInsideLabel);
    const textFieldClassNames = TextFieldInput.getTextFieldClasses(isReadonly, variant);
    const cssClassNames = classNames.classNames([formControlClassNames, textFieldClassNames]);
    return jsxRuntime.jsx("div", Object.assign({}, props, { class: cssClassNames }));
};

// TODO: Do we need named props for start/endContent, or could they just be children that get
// wrapped in a flex layout?  (from review on 3/8/22)
// TODO: Instead of passing the inputElem, label, and userAssistance as named props here, should we
// have a separate layout component that lays them out, which could just be passed as a child
// to the TextField?  (from review on 3/8/22)
const TextField = ({ contentVariant, id, endContent, mainContent, startContent, inlineUserAssistance, label, labelEdge, labelStartWidth, mainFieldRef, resize, statusVariant, styleVariant, onFocus, onBlur, onKeyDown, onMouseDown, onMouseEnter, onMouseLeave }) => {
    // TODO: What are the implications for interoperability between new preact-based form components
    // and the existing JET oj-form-layout?  The preact form components create their own start/top
    // labels, while oj-form-layout expects to create those itself and wire them to the existing form
    // components through attributes like labelled-by.  (from review on 3/8/22)
    // TODO: How should a parent form component render component-specific content within TextField,
    // for example an aria live region?  Instead of a children prop on TextField, could the parent
    // component pass comp-specific content through other props, like inputElem?   The parent could
    // have its own component that composes inputElem with additional DOM.  (from review on 3/8/22)
    const styledTextFieldChildren = label !== undefined && (labelEdge === 'start' || labelEdge === 'top') ? (jsxRuntime.jsx(UNSAFE_LabelValueLayout.LabelValueLayout, Object.assign({ label: label, labelEdge: labelEdge, labelStartWidth: labelStartWidth }, { children: jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsx(TextFieldContent, { contentVariant: contentVariant, endContent: endContent, mainContent: mainContent, resize: resize, rootRef: mainFieldRef, startContent: startContent, statusVariant: statusVariant, styleVariant: styleVariant }), inlineUserAssistance] }) }))) : (jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsx(TextFieldContent, { contentVariant: contentVariant, endContent: endContent, insideLabel: label, mainContent: mainContent, resize: resize, rootRef: mainFieldRef, startContent: startContent, statusVariant: statusVariant, styleVariant: styleVariant }), inlineUserAssistance] }));
    return (jsxRuntime.jsx(StyledTextField, Object.assign({ id: id, hasInsideLabel: label !== undefined && labelEdge === 'inside', onfocusin: onFocus, onfocusout: onBlur, onKeyDown: onKeyDown, onMouseDown: onMouseDown, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, variant: styleVariant }, { children: styledTextFieldChildren })));
};

const MAX_LENGTH_UPDATE_DELAY = 500;
function MaxLengthLiveRegion({ isMaxLengthExceeded, maxLength, valueLength = 0 }) {
    // Comment copied from InputBase.js in Big JET:
    // Only update the aria-live div when the user has paused for more than
    // 500 milliseconds. That way, we avoid queued up aria-live messages which
    // would be annoying and not helpful. The 500ms was agreed upon in the
    // accessibility review meeting.
    const debouncedRemainingChars = hooks_UNSAFE_useDebounce.useDebounce(maxLength - valueLength, MAX_LENGTH_UPDATE_DELAY);
    const translations = hooks_UNSAFE_useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const maxLengthExceededTranslatedString = translations.formControl_maxLengthExceeded({
        MAX_LENGTH: `${maxLength}`
    });
    const remainingCharsTranslatedString = translations.formControl_maxLengthRemaining({
        CHARACTER_COUNT: `${debouncedRemainingChars}`
    });
    return (jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsx(UNSAFE_LiveRegion.LiveRegion, { children: remainingCharsTranslatedString }), isMaxLengthExceeded && (jsxRuntime.jsx(UNSAFE_LiveRegion.LiveRegion, Object.assign({ type: "assertive" }, { children: maxLengthExceededTranslatedString })))] }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

exports.ReadonlyTextFieldInput = ReadonlyTextFieldInput.ReadonlyTextFieldInput;
exports.TextFieldInput = TextFieldInput.TextFieldInput;
exports.getInputId = TextFieldInput.getInputId;
exports.MaxLengthLiveRegion = MaxLengthLiveRegion;
exports.ReadonlyTextField = ReadonlyTextField;
exports.TextField = TextField;
/*  */
//# sourceMappingURL=UNSAFE_TextField.js.map

/* @oracle/oraclejet-preact: 14.0.4 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib_es6 = require('./tslib.es6-e79a0c43.js');
var jsxRuntime = require('preact/jsx-runtime');
var utils_UNSAFE_size = require('./utils/UNSAFE_size.js');
require("identity-obj-proxy");
require('./utils/UNSAFE_classNames.js');
var utils_UNSAFE_mergeProps = require('./utils/UNSAFE_mergeProps.js');
var hooks = require('preact/hooks');
var hooks_UNSAFE_useUser = require('./hooks/UNSAFE_useUser.js');
var hooks_PRIVATE_useDvtMeterEvents = require('./hooks/PRIVATE_useDvtMeterEvents.js');
var utils_PRIVATE_meterUtils = require('./utils/PRIVATE_meterUtils.js');
var PRIVATE_Meter = require('./PRIVATE_Meter.js');
var classNames = require('./classNames-fe0c9b44.js');
var hooks_UNSAFE_useTabbableMode = require('./hooks/UNSAFE_useTabbableMode.js');
require('./UNSAFE_Environment.js');
require('preact');
require('./UNSAFE_Layer.js');
require('preact/compat');
require('./hooks/UNSAFE_useTooltip.js');
require('./hooks/UNSAFE_useId.js');
require('./UNSAFE_Floating.js');
require('./Floating-cea8b705.js');
require('./index-b2f63b8c.js');
require('./utils/PRIVATE_floatingUtils.js');
require('./utils/PRIVATE_refUtils.js');
require('./hooks/UNSAFE_useOutsideClick.js');
require('./utils/UNSAFE_arrayUtils.js');
require('./hooks/UNSAFE_useHover.js');
require('./hooks/UNSAFE_useToggle.js');
require('./hooks/UNSAFE_useFocus.js');
require('./hooks/UNSAFE_useTouch.js');
require('./hooks/UNSAFE_useAnimation.js');
require('./useAnimation-694a2e01.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the metric value of the clicked point.
 * @param event The PointerEvent
 * @param dimensionsRef Ref to stored dimensions of the meter bar.
 * @param min The minimum value of the meter bar.
 * @param max The maximum value of the meter bar.
 * @param step The step value of the meter bar.
 * @param orientation The orientation of the meter bar.
 * @param isRtl Whether the reading mode is 'rtl'
 * @returns The metric value of the clicked point.
 */
function getValue(event, dimensionsRef, min, max, step, orientation, isRtl) {
    const dims = dimensionsRef.current;
    if (!dims || dims.width === 0) {
        return undefined;
    }
    let val;
    if (orientation === 'horizontal') {
        const width = event.offsetX;
        val = min + ((max - min) * (isRtl ? dims.width - width : width)) / dims.width;
    }
    else {
        const height = dims.height - event.offsetY;
        val = min + ((max - min) * height) / dims.height;
    }
    val = Math.round(val / step) * step;
    return Math.max(min, Math.min(max, val));
}
/**
 * Returns the true dimension of the meter bar after first render. All dimensions are 0 for initial render.
 * @param element The meter bar track HTML element
 * @returns The dimension of the meter bar.
 */
function getDimensions(element) {
    if (!element) {
        return {
            width: 0,
            height: 0
        };
    }
    const trackDims = element.getBoundingClientRect();
    return {
        width: trackDims.width,
        height: trackDims.height
    };
}
/**
 * Returns object with 'start' and 'end' keys. Value for each key will be true if at least one ref line with correposnding position is present in meter bar.
 * @param lines The array of reference lines.
 * @returns Returns object with start and end keys.
 */
function getRefLinesInfo(lines) {
    let refLineInfo = { start: false, end: false };
    if (lines) {
        refLineInfo = lines.reduce((acc, cur) => {
            acc.start = acc.start || cur.position === 'start';
            acc.end = acc.end || cur.position === 'end' || cur.position == null;
            return acc;
        }, refLineInfo);
    }
    return refLineInfo;
}
/**
 * Returns the total component size taking into account the presence or absence of
 * reference line in either or both side of reference bar. This method assumes that reference line
 * is always larger than the track size.
 * @param refLineInfo Object sepecifying if ref lines with start, end or both position are present.
 * @param size The size of the meter bar.
 * @returns {string}
 */
function getComponentSize(refLineInfo, size) {
    const barTrackSize = `var(--oj-c-PRIVATE-DO-NOT-USE-meter-bar-${size}-size)`;
    const refLineSize = 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-bar-refline-size)';
    if (refLineInfo.start && refLineInfo.end) {
        return `calc((2 * ${refLineSize}) - ${barTrackSize})`;
    }
    if (refLineInfo.start || refLineInfo.end) {
        return refLineSize;
    }
    return barTrackSize;
}

function ReferenceLineBar({
  orientation,
  percentage,
  color,
  position
}) {
  const isHoriz = orientation === 'horizontal';
  const {
    direction
  } = hooks_UNSAFE_useUser.useUser();
  const isRtl = direction === 'rtl';
  const isStartPos = position === 'start';
  return jsxRuntime.jsx("div", {
    class: classNames.classNames([styles$1.base, styles$1[`${orientation}Border`], styles$1[`${orientation}`], isStartPos ? isHoriz ? styles$1.horiontalStart : styles$1[`verticalStart${isRtl ? 'Rtl' : 'Ltr'}`] : '']),
    style: {
      left: isHoriz && !isRtl ? percentage : undefined,
      right: isHoriz && isRtl ? percentage : undefined,
      bottom: isHoriz ? undefined : percentage,
      backgroundColor: color
    }
  });
}
const styles$1 = {
  base: "_1il27gr",
  verticalBorder: "_1tsf40m",
  horizontalBorder: "lhtlxk",
  vertical: "v497j3",
  horizontal: "_1t8qxxd",
  horiontalStart: "l3yect",
  verticalStartLtr: "_63jo9c",
  verticalStartRtl: "lsrph9"
};

function ThresholdBar(_a) {
  var {
    color,
    length,
    orientation
  } = _a,
      otherProps = tslib_es6.__rest(_a, ["color", "length", "orientation"]);

  const {
    direction
  } = hooks_UNSAFE_useUser.useUser();
  const isHoriz = orientation === 'horizontal';
  const isRtl = direction === 'rtl';
  return jsxRuntime.jsx("div", {
    class: classNames.classNames([styles.base, isHoriz ? styles[`horizontalBarTrackSection${isRtl ? 'Rtl' : 'Ltr'}`] : styles['verticalBarTrackSection'], otherProps.class]),
    style: {
      width: isHoriz ? length : '100%',
      height: isHoriz ? '100%' : length,
      backgroundColor: color
    }
  });
}
const styles = {
  base: "_13hy386",
  verticalBarTrackSection: "_1rl0wxf",
  horizontalBarTrackSectionRtl: "us5i2i",
  horizontalBarTrackSectionLtr: "_2f1xsh"
};

/**
 * A Meter bar displays information graphically in a rectangular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds.
 */

function MeterBar(_a) {
  var _b, _c;

  var {
    max = 100,
    min = 0,
    value = 0,
    step = 1,
    length = '100%',
    size = 'lg',
    orientation = 'horizontal',
    isTrackRendered = true,
    thresholdDisplay = 'all',
    indicatorSize = 1
  } = _a,
      props = tslib_es6.__rest(_a, ["max", "min", "value", "step", "length", "size", "orientation", "isTrackRendered", "thresholdDisplay", "indicatorSize"]);

  utils_PRIVATE_meterUtils.validateRange(min, max, value, step);
  const isHoriz = orientation === 'horizontal';
  const barTrackRef = hooks.useRef(null);
  const dimensionsRef = hooks.useRef(getDimensions(null));
  const {
    direction
  } = hooks_UNSAFE_useUser.useUser();
  const isRtl = direction === 'rtl';
  hooks.useEffect(() => {
    if (props.onCommit || props.onInput) {
      dimensionsRef.current = getDimensions(barTrackRef.current);
    }
  }, [size, length, orientation, props.onCommit, props.onInput]);

  const getValueFromEvent = event => {
    // only evaluate value from bar track
    if (event.target == barTrackRef.current) {
      return getValue(event, dimensionsRef, min, max, step, orientation, isRtl);
    }

    return;
  };

  const pointerEventsProps = hooks_PRIVATE_useDvtMeterEvents.usePointerEvents(value, getValueFromEvent, barTrackRef, props.onCommit, props.onInput);
  const keyboardEventsProps = hooks_PRIVATE_useDvtMeterEvents.useKeyboardEvents(value, min, max, step, props.onCommit, props.onInput);
  const {
    datatipContent,
    datatipProps
  } = hooks_PRIVATE_useDvtMeterEvents.useMeterDatatip(value, props.datatip, props.ariaDescribedBy);
  const ariaLabelProps = utils_PRIVATE_meterUtils.getMeterAriaProps(value, min, max, `${value}`, props.accessibleLabel, props.ariaLabelledBy, props.thresholds);
  const mergedProps = utils_UNSAFE_mergeProps.mergeProps(pointerEventsProps, keyboardEventsProps, datatipProps, ariaLabelProps);
  const validIndicatorSize = Math.max(0, Math.min(1, indicatorSize));
  const valueBarLength = `${(value - min) * 100 / (max - min)}%`;
  const valueBarSize = `${validIndicatorSize * 100}%`;
  const {
    trackColor,
    indicatorColor
  } = utils_PRIVATE_meterUtils.getTrackAndIndicatorColor(value, thresholdDisplay, props.trackColor, props.indicatorColor, props.thresholds);
  const sizeStyle = getRefLinesInfo(props.referenceLines);
  const isInteractive = props.onCommit || props.onInput;
  const {
    isTabbable
  } = hooks_UNSAFE_useTabbableMode.useTabbableMode();
  return jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [jsxRuntime.jsx("div", Object.assign({
      tabIndex: !isTabbable ? -1 : 0,
      role: "slider"
    }, mergedProps, {
      style: {
        width: isHoriz ? utils_UNSAFE_size.sizeToCSS(length) : undefined,
        height: isHoriz ? undefined : utils_UNSAFE_size.sizeToCSS(length)
      },
      class: classNames.classNames([componentStyles.base, componentStyles[orientation]])
    }, {
      children: jsxRuntime.jsxs(PRIVATE_Meter.BarTrack, Object.assign({
        ref: barTrackRef,
        orientation: orientation,
        color: !isTrackRendered || thresholdDisplay === 'all' && props.thresholds ? 'transparent' : trackColor,
        class: classNames.classNames([barTrackStyles.base, isInteractive ? componentStyles.interactive : '', isHoriz ? '' : barTrackStyles.vertical, isHoriz ? barTrackStyles[`${size}Horizontal`] : barTrackStyles[`${size}Vertical`], ...getMarginClass(sizeStyle, size, isHoriz)])
      }, {
        children: [thresholdDisplay === 'all' && ((_b = props.thresholds) === null || _b === void 0 ? void 0 : _b.filter(threshold => threshold.max > min && threshold.max <= max).sort((a, b) => a.max - b.max).map((threshold, index, thresholds) => {
          const diff = index === 0 ? threshold.max - min : threshold.max - thresholds[index - 1].max;
          return jsxRuntime.jsxs(jsxRuntime.Fragment, {
            children: [jsxRuntime.jsx(ThresholdBar, {
              class: index === 0 ? trackSectionStyle[`${orientation}First`] : '',
              orientation: orientation,
              length: `${diff * 100 / (max - min)}%`,
              color: threshold.color
            }), isTrackRendered && index === thresholds.length - 1 && threshold.max < max ? jsxRuntime.jsx(ThresholdBar, {
              class: trackSectionStyle[`${orientation}Last`],
              color: trackColor,
              orientation: orientation,
              length: `${(max - thresholds[index].max) * 100 / (max - min)}%`
            }) : '']
          });
        })), jsxRuntime.jsx(PRIVATE_Meter.BarValue, {
          length: valueBarLength,
          size: valueBarSize,
          orientation: orientation,
          class: classNames.classNames([barValueStyles.base, barValueStyles[orientation]]),
          color: indicatorColor
        }), (_c = props.referenceLines) === null || _c === void 0 ? void 0 : _c.map(item => jsxRuntime.jsx(ReferenceLineBar, {
          color: item.color,
          orientation: orientation,
          percentage: `${(item.value - min) * 100 / (max - min)}%`,
          position: item.position
        }))]
      }))
    })), datatipContent]
  });
}

const getMarginClass = function (info, size, isHoriz) {
  const className = [];

  if (info.start) {
    className.push(barTrackStyles[`${size}Margin${isHoriz ? 'Top' : 'Start'}`]);
  }

  if (info.end) {
    className.push(barTrackStyles[`${size}Margin${isHoriz ? 'Bottom' : 'End'}`]);
  }

  return className;
};

const componentStyles = {
  base: "_1djr1mo",
  horizontal: "_4fioe",
  vertical: "_1h4aroh",
  interactive: "_1mi2mlw"
};
const barValueStyles = {
  base: "_1mhlen2",
  vertical: "_1w1w0ng",
  horizontal: "_1h2e1m0"
};
const barTrackStyles = {
  base: "_1231aw2",
  vertical: "p3ixi0",
  smHorizontal: "jafqcq",
  smVertical: "nkojca",
  mdHorizontal: "_1of7ei0",
  mdVertical: "pr47fm",
  lgHorizontal: "_1r6nrtp",
  lgVertical: "_2m2fqk",
  smMarginTop: "hkwp02",
  mdMarginTop: "_13af1l4",
  lgMarginTop: "_1nhz76a",
  smMarginStart: "reckw2",
  mdMarginStart: "lwf3os",
  lgMarginStart: "_1jjgd1y",
  smMarginEnd: "a6ck84",
  mdMarginEnd: "vn7tak",
  lgMarginEnd: "_1tm25z2",
  smMarginBottom: "_108dznk",
  mdMarginBottom: "_9mcqgr",
  lgMarginBottom: "lusjyt"
};
const trackSectionStyle = {
  horizontalFirst: "_1injukn",
  horizontalLast: "_1o2a2sw",
  verticalFirst: "umweak",
  verticalLast: "_19h8qtv"
};

exports.MeterBar = MeterBar;
/*  */
//# sourceMappingURL=UNSAFE_MeterBar.js.map

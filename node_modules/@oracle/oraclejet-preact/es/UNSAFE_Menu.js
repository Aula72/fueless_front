/* @oracle/oraclejet-preact: 14.0.4 */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { useCallback, useRef, useState, useEffect, useContext, useMemo, useLayoutEffect } from 'preact/hooks';
import { Floating } from './UNSAFE_Floating.js';
import { Layer } from './UNSAFE_Layer.js';
import { useOutsideClick } from './hooks/UNSAFE_useOutsideClick.js';
import { useCollectionFocusRing } from './hooks/PRIVATE_useCollectionFocusRing.js';
import { mergeProps } from './utils/UNSAFE_mergeProps.js';
import "./UNSAFE_Menu.css";
import { createContext } from 'preact';
import { Text } from './UNSAFE_Text.js';
import { useHover } from './hooks/UNSAFE_useHover.js';
import { classNames } from './utils/UNSAFE_classNames.js';
import { useId } from './hooks/UNSAFE_useId.js';
import { usePress } from './hooks/UNSAFE_usePress.js';
import { getClientHints } from './utils/PRIVATE_clientHints.js';
import { Divider } from './UNSAFE_Divider.js';
import 'preact/compat';
import './index-35a194f0.js';
import './hooks/UNSAFE_useUser.js';
import './UNSAFE_Environment.js';
import './utils/PRIVATE_floatingUtils.js';
import './utils/PRIVATE_refUtils.js';
import './utils/UNSAFE_arrayUtils.js';
import './tslib.es6-5eaa88c2.js';
import './utils/UNSAFE_mergeInterpolations.js';
import './_curry1-f2673bab.js';
import './_curry3-6b8e8079.js';
import './_curry2-d7587d88.js';
import './_has-cbbf4e16.js';
import './hooks/UNSAFE_useToggle.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Context used to pass menu information without having to pass it to menu children props.
 * We want to communicate information down to any interested menu item children.
 */
const MenuContext = createContext({
    onClose: () => null,
    currentKey: undefined,
    showFocusRing: false
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook for handling current key update due to user interaction including keyboard navigation.
 *
 * @param keyExtractor function to extract the key based on the provided element
 * @param getPrevKey function to get the previous key based on the current key
 * @param getNextKey function to get the next key based on the current key
 * @param getFirstVisibleKey function to get the key of the first available item
 * @param getLastVisibleKey function to get the key of the last available item
 * @param currentKey the current key
 * @param onChange function to invoke if the current key has changed
 * @returns
 */
function useMenuCurrentKey(keyExtractor, getPrevKey, getNextKey, getFirstVisibleKey, getLastVisibleKey, currentKey, onChange) {
    const onKeyDown = useCallback((event) => {
        if (onChange) {
            // TODO: support horizontal layout on icon menu (left/right arrow key)
            if (event.key === 'ArrowDown' && !event.shiftKey) {
                const nextKey = getNextKey();
                if (nextKey && currentKey != nextKey) {
                    onChange({ value: nextKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'ArrowUp' && !event.shiftKey) {
                const prevKey = getPrevKey();
                if (prevKey && currentKey != prevKey) {
                    onChange({ value: prevKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'Home') {
                const firstKey = getFirstVisibleKey();
                if (firstKey && currentKey != firstKey) {
                    onChange({ value: firstKey });
                }
                event.preventDefault();
            }
            else if (event.key === 'End') {
                const lastKey = getLastVisibleKey();
                if (lastKey && currentKey != lastKey) {
                    onChange({ value: lastKey });
                }
                event.preventDefault();
            }
        }
    }, [currentKey, getNextKey, getPrevKey, onChange, getFirstVisibleKey, getLastVisibleKey]);
    //Capture needed since usePress stop propagation, what produces not triggering this event.
    //We can't stop propagation here, because if we do that, usePress onClick will not be triggered.
    const onClickCapture = useCallback((event) => {
        if (onChange && !event.shiftKey) {
            const nextKey = keyExtractor(event.target);
            if (nextKey && currentKey != nextKey) {
                onChange({ value: nextKey });
            }
        }
    }, [currentKey, keyExtractor, onChange]);
    const currentKeyProps = onChange == null ? {} : { onClickCapture, onKeyDown };
    return { currentKeyProps };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the key from the item element
 */
const getKey = (item) => {
    // Key is set on data-oj-menu-item-key on each menuItem. To get this key from the
    // the actual menuItem we need to do a kebab to camel-case conversion.
    return item.dataset['ojMenuItemKey'];
};
/**
 * A helper function that return the key of the first available item.
 */
const getFirstVisibleKey = (root) => {
    if (root) {
        const firstItem = root.querySelector('[data-oj-menu-item-key]');
        if (firstItem) {
            const key = getKey(firstItem);
            if (key) {
                return key;
            }
        }
    }
    return null;
};
/**
 * A helper function that return the key of the last available item.
 */
const getLastVisibleKey = (root) => {
    if (root) {
        const items = root.querySelectorAll('[data-oj-menu-item-key]');
        const lastItem = items[items.length - 1];
        if (lastItem) {
            const key = getKey(lastItem);
            if (key) {
                return key;
            }
        }
    }
    return null;
};
/**
 * A helper function that returns the key of the previous or the next item
 * given the specified current key
 */
const getPrevNextKey = (root, isPrev, currentKey) => {
    return () => {
        if (root) {
            const items = Array.from(root.querySelectorAll('[data-oj-menu-item-key]'));
            const currentKeyIndex = items.findIndex((item) => getKey(item) === currentKey);
            let nextIndex = currentKeyIndex + (isPrev ? -1 : 1);
            const itemsLastIndex = items.length - 1;
            if (nextIndex < 0) {
                nextIndex = itemsLastIndex;
            }
            if (nextIndex > itemsLastIndex) {
                nextIndex = 0;
            }
            return getKey(items[nextIndex]) || null;
        }
        return null;
    };
};
/**
 * A helper function to get the key from an element
 */
const keyExtractor = (element) => {
    const item = element.closest('[data-oj-menu-item-key]');
    if (item) {
        const key = getKey(item);
        return key === undefined ? null : key;
    }
    return null;
};
/**
 * Function to get the corresponding keyboard behavior to close the menu.
 */
const getKeyboardCloseProps = (onClose) => {
    const onKeyDown = (event) => {
        if (event.key === 'Tab') {
            onClose === null || onClose === void 0 ? void 0 : onClose({ reason: 'tabbing' });
            event.preventDefault(); //TODO: Revisit this since we should let focus be at its natural flow, quick solution for now to focus correct item in main use case
        }
        else if (event.key === 'Escape') {
            onClose === null || onClose === void 0 ? void 0 : onClose({ reason: 'cancel' });
        }
    };
    return { onKeyDown };
};
/**
 * Function to get the corresponding specific behavior for clicking/touching down menuContainer
 */
const getMenuPointerDown = () => {
    const onPointerDown = (event) => {
        //We just want to prevent default when element that was
        //pressed down was not a menu item. Using this flag removes issues
        //related to focus visibilty on "long press"
        const nextKey = keyExtractor(event.target);
        if (!nextKey) {
            event.preventDefault();
        }
    };
    return { onPointerDown };
};

const styles$2 = {
  // TODO: Handle vertical and horizontal overflow. Get rid of maxWidth on a next drop so horizontal and also vertical flow is handled correctly.
  // It's hard to relay just in css, we might need to relay on some kind of observer. Maybe should be handled on Floating/Dropdown component.
  floatingContainer: "cgffya",
  menuContainer: "_15bff7d"
};
const Menu = ({
  children,
  isOpen = false,
  anchorRef,
  onClose,
  accessibleLabel,
  initialFocus = 'menu'
}) => {
  const floatingRef = useRef(null);
  const menuContainerRef = useRef(null);
  const isOpenPrevValue = useRef();
  const [currentKey, setCurrentKey] = useState();
  const [possibleFocus, setPossibleFocus] = useState('pending');
  const changeKey = useCallback(detail => {
    setCurrentKey(detail.value);
    setPossibleFocus('firstItem');
  }, []);
  const [showFocusRing, focusRingProps] = useCollectionFocusRing(elem => {
    var _a;

    return !!((_a = menuContainerRef.current) === null || _a === void 0 ? void 0 : _a.contains(elem));
  }, ['ArrowUp', 'ArrowDown'], elem => {
    const nextKey = keyExtractor(elem);
    return !!nextKey;
  });
  const {
    currentKeyProps
  } = useMenuCurrentKey(element => keyExtractor(element), getPrevNextKey(menuContainerRef.current, true, currentKey), getPrevNextKey(menuContainerRef.current, false, currentKey), () => getFirstVisibleKey(menuContainerRef.current), () => getLastVisibleKey(menuContainerRef.current), currentKey, changeKey);
  const useOutsideClickHandler = useCallback(e => {
    onClose === null || onClose === void 0 ? void 0 : onClose({
      reason: 'outsideClick',
      target: e.target
    });
  }, [onClose]);
  useOutsideClick({
    isDisabled: !isOpen,
    ref: [floatingRef],
    handler: useOutsideClickHandler
  });
  useEffect(() => {
    if (isOpen === isOpenPrevValue.current) return;

    if (isOpen) {
      const menuContainer = menuContainerRef.current;

      if (menuContainer) {
        if (initialFocus === 'menu') {
          // At this point floating has visibility set as hidden, so also menuContainer. Settimeout added so menuContainer
          // is visible at that point and can be focused
          setTimeout(() => {
            menuContainer.focus();
          }, 0);
          setPossibleFocus('menu');
        } else {
          const firstItemKey = getFirstVisibleKey(menuContainerRef.current);

          if (firstItemKey) {
            changeKey({
              value: firstItemKey
            });
          } else {
            setPossibleFocus('menu');
          }
        }
      }
    } else {
      setPossibleFocus('pending');
      setCurrentKey(undefined);
    }

    isOpenPrevValue.current = isOpen;
  }, [isOpen, initialFocus, changeKey]); // TODO - Reuse a dropdown component instead of creating floating by ourselves.

  return !isOpen ? null : jsx(Layer, Object.assign({
    logicalParentRef: anchorRef
  }, {
    children: jsx(Floating, Object.assign({
      class: styles$2.floatingContainer,
      ref: floatingRef,
      anchorRef: anchorRef,
      placement: "bottom-start",
      offsetValue: {
        mainAxis: 4,
        crossAxis: 0
      }
    }, {
      children: jsx(MenuContext.Provider, Object.assign({
        value: {
          onClose,
          currentKey,
          showFocusRing
        }
      }, {
        children: jsx("div", Object.assign({
          style: {
            minWidth: `${anchorRef.current && anchorRef.current.offsetWidth > MENU_MIN_WIDTH ? anchorRef.current.offsetWidth : MENU_MIN_WIDTH}px`
          },
          ref: menuContainerRef,
          tabIndex: possibleFocus === 'firstItem' ? -1 : 0,
          role: "menu",
          "aria-label": accessibleLabel,
          class: styles$2.menuContainer
        }, mergeProps(focusRingProps, currentKeyProps, getMenuPointerDown(), getKeyboardCloseProps(onClose)), {
          children: children
        }))
      }))
    }))
  }));
};
const MENU_MIN_WIDTH = 200;

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Utility hook for consuming the MenuContext
 *
 * @returns The value of MenuContext provider
 */
function useMenuContext() {
    return useContext(MenuContext);
}

const styles$1 = {
  menuItemContainer: "_1tibxxl",
  focused: "_1lxdg1s",
  variant: {
    default: {
      menuItemContainer: "c2hdwf",
      hover: "ou7hrt",
      pseudohover: "g1rir0"
    },
    destructive: {
      menuItemContainer: "_177ecgt",
      hover: "_1xtyeiq",
      pseudohover: "mes3s1"
    }
  },
  iconLabelContainer: "_1olgne2",
  labelContainer: "qu6sic",
  iconContainer: "_1cmy50o",
  startIconContainer: "ui2opd",
  endIconContainer: "_5wfx0",
  disabledContainer: "_1dobc0p"
};
function MenuItem(props) {
  return jsx(BaseMenuItem, Object.assign({}, props, {
    role: "menuitem"
  }));
}
const isHybrid = getClientHints().isHybrid;
function BaseMenuItem({
  label,
  onAction,
  startIcon,
  endIcon,
  role,
  isChecked,
  isDisabled = false,
  variant = 'default'
}) {
  const {
    onClose,
    currentKey,
    showFocusRing
  } = useMenuContext();
  const uniqueID = useId();
  const id = useMemo(() => `oj-menu-item-${uniqueID}`, [uniqueID]);
  const isCurrent = currentKey === id;
  const menuItemRef = useRef(null);
  const {
    hoverProps,
    isHover
  } = useHover({
    isDisabled: !isHybrid
  });

  const handleItemSelection = () => {
    onClose === null || onClose === void 0 ? void 0 : onClose({
      reason: 'itemAction'
    });
    onAction === null || onAction === void 0 ? void 0 : onAction();
  };

  const {
    pressProps
  } = usePress(handleItemSelection, {
    isDisabled
  });
  useLayoutEffect(() => {
    var _a;

    if (isCurrent) {
      (_a = menuItemRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }, [isCurrent]);
  const menuItemContainerClasses = classNames([styles$1.menuItemContainer, !isDisabled && styles$1.variant[variant].menuItemContainer, isDisabled && styles$1.disabledContainer, !isHybrid && !isDisabled && styles$1.variant[variant].pseudohover, isHybrid && isHover && !isDisabled && styles$1.variant[variant].hover, isCurrent && !!showFocusRing && styles$1.focused]);
  const startIconContainerClasses = classNames([styles$1.iconLabelContainer, styles$1.iconContainer, styles$1.startIconContainer]);
  const labelContainerClasses = classNames([styles$1.iconLabelContainer, styles$1.labelContainer]);
  const endIconContainerClasses = classNames([styles$1.iconLabelContainer, styles$1.iconContainer, styles$1.endIconContainer]);
  return jsxs("a", Object.assign({
    ref: menuItemRef,
    class: menuItemContainerClasses
  }, mergeProps(hoverProps, pressProps), {
    role: role,
    "data-oj-menu-item-key": id
  }, isDisabled && {
    'aria-disabled': true
  }, role !== 'menuitem' && {
    'aria-checked': isChecked
  }, {
    tabIndex: isCurrent ? 0 : -1
  }, {
    children: [startIcon && jsx("span", Object.assign({
      class: startIconContainerClasses
    }, {
      children: startIcon
    })), jsx("span", Object.assign({
      class: labelContainerClasses
    }, {
      children: jsx(Text, Object.assign({
        variant: "inherit",
        size: "md"
      }, {
        children: label
      }))
    })), endIcon && jsx("span", Object.assign({
      class: endIconContainerClasses
    }, {
      children: endIcon
    }))]
  }));
}

const styles = {
  menuDividerContainer: "s1txzu"
};
function MenuDivider() {
  return jsx("div", Object.assign({
    class: styles.menuDividerContainer
  }, {
    children: jsx(Divider, {})
  }));
}

export { Menu, MenuDivider, MenuItem };
/*  */
//# sourceMappingURL=UNSAFE_Menu.js.map

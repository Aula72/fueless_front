/* @oracle/oraclejet-preact: 14.0.4 */
import { _ as __rest } from './tslib.es6-5eaa88c2.js';
import { jsx, jsxs, Fragment } from 'preact/jsx-runtime';
import { sizeToCSS } from './utils/UNSAFE_size.js';
import "./UNSAFE_MeterBar.css";
import { classNames } from './utils/UNSAFE_classNames.js';
import { mergeProps } from './utils/UNSAFE_mergeProps.js';
import { useRef, useEffect } from 'preact/hooks';
import { useUser } from './hooks/UNSAFE_useUser.js';
import { usePointerEvents, useKeyboardEvents, useMeterDatatip } from './hooks/PRIVATE_useDvtMeterEvents.js';
import { validateRange, getMeterAriaProps, getTrackAndIndicatorColor } from './utils/PRIVATE_meterUtils.js';
import { BarTrack, BarValue } from './PRIVATE_Meter.js';
import { useTabbableMode } from './hooks/UNSAFE_useTabbableMode.js';
import './UNSAFE_Environment.js';
import 'preact';
import './UNSAFE_Layer.js';
import 'preact/compat';
import './hooks/UNSAFE_useTooltip.js';
import './hooks/UNSAFE_useId.js';
import './UNSAFE_Floating.js';
import './index-35a194f0.js';
import './utils/PRIVATE_floatingUtils.js';
import './utils/PRIVATE_refUtils.js';
import './hooks/UNSAFE_useOutsideClick.js';
import './utils/UNSAFE_arrayUtils.js';
import './hooks/UNSAFE_useHover.js';
import './hooks/UNSAFE_useToggle.js';
import './hooks/UNSAFE_useFocus.js';
import './hooks/UNSAFE_useTouch.js';
import './hooks/UNSAFE_useAnimation.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the metric value of the clicked point.
 * @param event The PointerEvent
 * @param dimensionsRef Ref to stored dimensions of the meter bar.
 * @param min The minimum value of the meter bar.
 * @param max The maximum value of the meter bar.
 * @param step The step value of the meter bar.
 * @param orientation The orientation of the meter bar.
 * @param isRtl Whether the reading mode is 'rtl'
 * @returns The metric value of the clicked point.
 */
function getValue(event, dimensionsRef, min, max, step, orientation, isRtl) {
    const dims = dimensionsRef.current;
    if (!dims || dims.width === 0) {
        return undefined;
    }
    let val;
    if (orientation === 'horizontal') {
        const width = event.offsetX;
        val = min + ((max - min) * (isRtl ? dims.width - width : width)) / dims.width;
    }
    else {
        const height = dims.height - event.offsetY;
        val = min + ((max - min) * height) / dims.height;
    }
    val = Math.round(val / step) * step;
    return Math.max(min, Math.min(max, val));
}
/**
 * Returns the true dimension of the meter bar after first render. All dimensions are 0 for initial render.
 * @param element The meter bar track HTML element
 * @returns The dimension of the meter bar.
 */
function getDimensions(element) {
    if (!element) {
        return {
            width: 0,
            height: 0
        };
    }
    const trackDims = element.getBoundingClientRect();
    return {
        width: trackDims.width,
        height: trackDims.height
    };
}
/**
 * Returns object with 'start' and 'end' keys. Value for each key will be true if at least one ref line with correposnding position is present in meter bar.
 * @param lines The array of reference lines.
 * @returns Returns object with start and end keys.
 */
function getRefLinesInfo(lines) {
    let refLineInfo = { start: false, end: false };
    if (lines) {
        refLineInfo = lines.reduce((acc, cur) => {
            acc.start = acc.start || cur.position === 'start';
            acc.end = acc.end || cur.position === 'end' || cur.position == null;
            return acc;
        }, refLineInfo);
    }
    return refLineInfo;
}
/**
 * Returns the total component size taking into account the presence or absence of
 * reference line in either or both side of reference bar. This method assumes that reference line
 * is always larger than the track size.
 * @param refLineInfo Object sepecifying if ref lines with start, end or both position are present.
 * @param size The size of the meter bar.
 * @returns {string}
 */
function getComponentSize(refLineInfo, size) {
    const barTrackSize = `var(--oj-c-PRIVATE-DO-NOT-USE-meter-bar-${size}-size)`;
    const refLineSize = 'var(--oj-c-PRIVATE-DO-NOT-USE-meter-bar-refline-size)';
    if (refLineInfo.start && refLineInfo.end) {
        return `calc((2 * ${refLineSize}) - ${barTrackSize})`;
    }
    if (refLineInfo.start || refLineInfo.end) {
        return refLineSize;
    }
    return barTrackSize;
}

function ReferenceLineBar({
  orientation,
  percentage,
  color,
  position
}) {
  const isHoriz = orientation === 'horizontal';
  const {
    direction
  } = useUser();
  const isRtl = direction === 'rtl';
  const isStartPos = position === 'start';
  return jsx("div", {
    class: classNames([styles$1.base, styles$1[`${orientation}Border`], styles$1[`${orientation}`], isStartPos ? isHoriz ? styles$1.horiontalStart : styles$1[`verticalStart${isRtl ? 'Rtl' : 'Ltr'}`] : '']),
    style: {
      left: isHoriz && !isRtl ? percentage : undefined,
      right: isHoriz && isRtl ? percentage : undefined,
      bottom: isHoriz ? undefined : percentage,
      backgroundColor: color
    }
  });
}
const styles$1 = {
  base: "_1il27gr",
  verticalBorder: "_1tsf40m",
  horizontalBorder: "lhtlxk",
  vertical: "v497j3",
  horizontal: "_1t8qxxd",
  horiontalStart: "l3yect",
  verticalStartLtr: "_63jo9c",
  verticalStartRtl: "lsrph9"
};

function ThresholdBar(_a) {
  var {
    color,
    length,
    orientation
  } = _a,
      otherProps = __rest(_a, ["color", "length", "orientation"]);

  const {
    direction
  } = useUser();
  const isHoriz = orientation === 'horizontal';
  const isRtl = direction === 'rtl';
  return jsx("div", {
    class: classNames([styles.base, isHoriz ? styles[`horizontalBarTrackSection${isRtl ? 'Rtl' : 'Ltr'}`] : styles['verticalBarTrackSection'], otherProps.class]),
    style: {
      width: isHoriz ? length : '100%',
      height: isHoriz ? '100%' : length,
      backgroundColor: color
    }
  });
}
const styles = {
  base: "_13hy386",
  verticalBarTrackSection: "_1rl0wxf",
  horizontalBarTrackSectionRtl: "us5i2i",
  horizontalBarTrackSectionLtr: "_2f1xsh"
};

/**
 * A Meter bar displays information graphically in a rectangular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds.
 */

function MeterBar(_a) {
  var _b, _c;

  var {
    max = 100,
    min = 0,
    value = 0,
    step = 1,
    length = '100%',
    size = 'lg',
    orientation = 'horizontal',
    isTrackRendered = true,
    thresholdDisplay = 'all',
    indicatorSize = 1
  } = _a,
      props = __rest(_a, ["max", "min", "value", "step", "length", "size", "orientation", "isTrackRendered", "thresholdDisplay", "indicatorSize"]);

  validateRange(min, max, value, step);
  const isHoriz = orientation === 'horizontal';
  const barTrackRef = useRef(null);
  const dimensionsRef = useRef(getDimensions(null));
  const {
    direction
  } = useUser();
  const isRtl = direction === 'rtl';
  useEffect(() => {
    if (props.onCommit || props.onInput) {
      dimensionsRef.current = getDimensions(barTrackRef.current);
    }
  }, [size, length, orientation, props.onCommit, props.onInput]);

  const getValueFromEvent = event => {
    // only evaluate value from bar track
    if (event.target == barTrackRef.current) {
      return getValue(event, dimensionsRef, min, max, step, orientation, isRtl);
    }

    return;
  };

  const pointerEventsProps = usePointerEvents(value, getValueFromEvent, barTrackRef, props.onCommit, props.onInput);
  const keyboardEventsProps = useKeyboardEvents(value, min, max, step, props.onCommit, props.onInput);
  const {
    datatipContent,
    datatipProps
  } = useMeterDatatip(value, props.datatip, props.ariaDescribedBy);
  const ariaLabelProps = getMeterAriaProps(value, min, max, `${value}`, props.accessibleLabel, props.ariaLabelledBy, props.thresholds);
  const mergedProps = mergeProps(pointerEventsProps, keyboardEventsProps, datatipProps, ariaLabelProps);
  const validIndicatorSize = Math.max(0, Math.min(1, indicatorSize));
  const valueBarLength = `${(value - min) * 100 / (max - min)}%`;
  const valueBarSize = `${validIndicatorSize * 100}%`;
  const {
    trackColor,
    indicatorColor
  } = getTrackAndIndicatorColor(value, thresholdDisplay, props.trackColor, props.indicatorColor, props.thresholds);
  const sizeStyle = getRefLinesInfo(props.referenceLines);
  const isInteractive = props.onCommit || props.onInput;
  const {
    isTabbable
  } = useTabbableMode();
  return jsxs(Fragment, {
    children: [jsx("div", Object.assign({
      tabIndex: !isTabbable ? -1 : 0,
      role: "slider"
    }, mergedProps, {
      style: {
        width: isHoriz ? sizeToCSS(length) : undefined,
        height: isHoriz ? undefined : sizeToCSS(length)
      },
      class: classNames([componentStyles.base, componentStyles[orientation]])
    }, {
      children: jsxs(BarTrack, Object.assign({
        ref: barTrackRef,
        orientation: orientation,
        color: !isTrackRendered || thresholdDisplay === 'all' && props.thresholds ? 'transparent' : trackColor,
        class: classNames([barTrackStyles.base, isInteractive ? componentStyles.interactive : '', isHoriz ? '' : barTrackStyles.vertical, isHoriz ? barTrackStyles[`${size}Horizontal`] : barTrackStyles[`${size}Vertical`], ...getMarginClass(sizeStyle, size, isHoriz)])
      }, {
        children: [thresholdDisplay === 'all' && ((_b = props.thresholds) === null || _b === void 0 ? void 0 : _b.filter(threshold => threshold.max > min && threshold.max <= max).sort((a, b) => a.max - b.max).map((threshold, index, thresholds) => {
          const diff = index === 0 ? threshold.max - min : threshold.max - thresholds[index - 1].max;
          return jsxs(Fragment, {
            children: [jsx(ThresholdBar, {
              class: index === 0 ? trackSectionStyle[`${orientation}First`] : '',
              orientation: orientation,
              length: `${diff * 100 / (max - min)}%`,
              color: threshold.color
            }), isTrackRendered && index === thresholds.length - 1 && threshold.max < max ? jsx(ThresholdBar, {
              class: trackSectionStyle[`${orientation}Last`],
              color: trackColor,
              orientation: orientation,
              length: `${(max - thresholds[index].max) * 100 / (max - min)}%`
            }) : '']
          });
        })), jsx(BarValue, {
          length: valueBarLength,
          size: valueBarSize,
          orientation: orientation,
          class: classNames([barValueStyles.base, barValueStyles[orientation]]),
          color: indicatorColor
        }), (_c = props.referenceLines) === null || _c === void 0 ? void 0 : _c.map(item => jsx(ReferenceLineBar, {
          color: item.color,
          orientation: orientation,
          percentage: `${(item.value - min) * 100 / (max - min)}%`,
          position: item.position
        }))]
      }))
    })), datatipContent]
  });
}

const getMarginClass = function (info, size, isHoriz) {
  const className = [];

  if (info.start) {
    className.push(barTrackStyles[`${size}Margin${isHoriz ? 'Top' : 'Start'}`]);
  }

  if (info.end) {
    className.push(barTrackStyles[`${size}Margin${isHoriz ? 'Bottom' : 'End'}`]);
  }

  return className;
};

const componentStyles = {
  base: "_1djr1mo",
  horizontal: "_4fioe",
  vertical: "_1h4aroh",
  interactive: "_1mi2mlw"
};
const barValueStyles = {
  base: "_1mhlen2",
  vertical: "_1w1w0ng",
  horizontal: "_1h2e1m0"
};
const barTrackStyles = {
  base: "_1231aw2",
  vertical: "p3ixi0",
  smHorizontal: "jafqcq",
  smVertical: "nkojca",
  mdHorizontal: "_1of7ei0",
  mdVertical: "pr47fm",
  lgHorizontal: "_1r6nrtp",
  lgVertical: "_2m2fqk",
  smMarginTop: "hkwp02",
  mdMarginTop: "_13af1l4",
  lgMarginTop: "_1nhz76a",
  smMarginStart: "reckw2",
  mdMarginStart: "lwf3os",
  lgMarginStart: "_1jjgd1y",
  smMarginEnd: "a6ck84",
  mdMarginEnd: "vn7tak",
  lgMarginEnd: "_1tm25z2",
  smMarginBottom: "_108dznk",
  mdMarginBottom: "_9mcqgr",
  lgMarginBottom: "lusjyt"
};
const trackSectionStyle = {
  horizontalFirst: "_1injukn",
  horizontalLast: "_1o2a2sw",
  verticalFirst: "umweak",
  verticalLast: "_19h8qtv"
};

export { MeterBar };
/*  */
//# sourceMappingURL=UNSAFE_MeterBar.js.map
